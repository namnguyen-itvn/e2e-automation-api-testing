ðŸ“Œ General Rules
	â€¢	Always use TypeScript with strict typing (tsconfig: strict: true).
	â€¢	Organize framework into POM-like structure for APIs:
	â€¢	tests/ â†’ test specs
	â€¢	pages/api/ â†’ API endpoint classes (encapsulate requests, like Page Objects)
	â€¢	utils/ â†’ common helpers (faker data, schema validation, logger, config)
	â€¢	fixtures/ â†’ reusable test data or setup/teardown logic
	â€¢	Use Playwright test runner (@playwright/test) with request fixture.
	â€¢	Use faker for realistic test data.
	â€¢	Follow AAA pattern (Arrange, Act, Assert) in tests.
	â€¢	Include comments for each step (Setup, Request, Assertion).
	â€¢	Avoid hardcoding values â†’ use config.ts or env variables.
	â€¢	Ensure idempotency: clean up test data after creation if necessary.

â¸»

ðŸ“Œ POM for APIs (Best Practice)
	â€¢	Treat each API resource like a Page Object.
	â€¢	Each API class should:
	â€¢	Accept request: APIRequestContext in constructor.
	â€¢	Expose methods for each endpoint (e.g., createUser(data), getUser(id)).
	â€¢	Return typed response models (User, Order, etc.) instead of raw JSON.
	â€¢	Handle status + body validation internally.
	â€¢	Example structure:
```
pages/api/
â”œâ”€â”€ BaseAPI.ts
â”œâ”€â”€ UsersAPI.ts
â”œâ”€â”€ OrdersAPI.ts
```
ðŸ“Œ Assertions & Validations
	â€¢	Always assert on:
	â€¢	Status code (expect(res.status()).toBe(200))
	â€¢	Critical response fields from history.json or schema
	â€¢	Use Playwright expect for response validation.
	â€¢	Use Zod / Joi / Yup (optional) for response schema validation.
	â€¢	Log response on failure for debugging.

â¸»

ðŸ“Œ Error Handling
	â€¢	Wrap critical calls in try/catch.
	â€¢	Print failed payload + response body on errors.
	â€¢	Use custom error classes in utils/errors.ts.

â¸»

ðŸ“Œ Example API Test with POM
```
// tests/user.spec.ts
import { test, expect } from '@playwright/test';
import { faker } from '@faker-js/faker';
import { UsersAPI } from '../pages/api/UsersAPI';

test.describe('User API Workflow', () => {
  test('should create and fetch user successfully', async ({ request }) => {
    const usersApi = new UsersAPI(request);

    // Arrange: test data
    const userData = {
      firstName: faker.person.firstName(),
      email: faker.internet.email(),
    };

    // Act: create user
    const createdUser = await usersApi.createUser(userData);

    // Assert: creation
    expect(createdUser.firstName).toBe(userData.firstName);

    // Act: fetch user
    const fetchedUser = await usersApi.getUser(createdUser.id);

    // Assert: fetched user matches
    expect(fetchedUser.email).toBe(userData.email);
  });
});
```

ðŸ“Œ Example API POM Class
```
// pages/api/UsersAPI.ts
import { APIRequestContext, expect } from '@playwright/test';

export class UsersAPI {
  constructor(private request: APIRequestContext) {}

  async createUser(user: { firstName: string; email: string }) {
    const response = await this.request.post('/users', { data: user });
    expect(response.status()).toBe(201);

    const body = await response.json();
    return body as { id: string; firstName: string; email: string };
  }

  async getUser(userId: string) {
    const response = await this.request.get(`/users/${userId}`);
    expect(response.status()).toBe(200);

    return (await response.json()) as { id: string; firstName: string; email: string };
  }
}
```
ðŸ“Œ Key Best Practices (SDET Level)
	1.	Reusability: Encapsulate endpoints in classes.
	2.	Maintainability: Centralize base URL, headers, and auth in BaseAPI.ts.
	3.	Scalability: Organize endpoints per resource (Users, Orders, Auth).
	4.	Data Management: Use faker + fixtures, avoid static test data.
	5.	Validation: Always check both status + response schema.
	6.	CI/CD Ready: Configurable base URLs via process.env.
	7.	Clean Tests: Keep test specs high-level; logic stays in POM.